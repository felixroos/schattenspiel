var kabelsalat=function(f){"use strict";class s{constructor(e,n){this.type=e,n!==void 0&&(this.value=n),this.ins=[]}}const g=(t,e)=>new s(t,e);let p=new Map;const w="poly",S="dac";function b(t,e){if(typeof t=="function"){if(!e)throw new Error("tried to parse function input without without passing node..");return e.apply(t)}return typeof t=="object"?t:typeof t=="number"&&!isNaN(t)||typeof t=="string"?k(t):(console.log(`invalid input type "${typeof t}" for node of type "${e.type}", falling back to 0. The input was:`,t),0)}s.prototype.inherit=function(t){return t.inputOf&&(this.inputOf=t.inputOf),t.outputOf&&(this.outputOf=t.outputOf),this},s.prototype.toObject=function(){return JSON.parse(JSON.stringify(this))},s.prototype.stringify=function(){return JSON.stringify(this,null,2).replaceAll('"',"'")};function $(t,...e){let n=1;if(e=e.map(o=>{if(Array.isArray(o)){if(o.length===1)return o[0];o=new s(w).withIns(...o)}return o.type===w&&(n=Math.max(o.ins.length,n)),o}),n===1){const o=g(t);return o.withIns(...e.map(u=>b(u,o)))}if(t===S){const o=e.map(u=>u.type===w?u.ins.map(a=>b(a).inherit(a)):u).flat();return g(S).withIns(...o)}const i=Array.from({length:n},(o,u)=>{const a=new s(t),r=e.map(l=>l.type===w?b(l.ins[u%l.ins.length],a).inherit(l):b(l,a));return a.withIns(...r)});return new s(w).withIns(...i)}function j(t,e){const n=p.get(t);return n?.ins?.[e]?n.ins[e].name:""}let R=(t,e)=>O(t,(...n)=>$(t,...n),e);p.set("register",{tags:["meta"],graph:!1,description:"Registers a new Node function. Sets it on the prototype + returns the function itself. Like `module` but doesn't hide complexity in graph viz.",examples:[`let kick = register('kick', gate => gate.adsr(0,.11,0,.11)
  .apply(env => env.mul(env)
    .mul(158)
    .sine(env)
    .distort(.85)
  ))
  impulse(2).kick().out()`]});let O=(t,e,n)=>(n&&p.set(t,n),s.prototype[t]=function(...i){return e(this,...i)},e);p.set("module",{tags:["meta"],graph:!0,description:"Creates a module. Like `register`, but the graph viz will hide the internal complexity of the module.",examples:[`let kick = module('kick', gate => gate.adsr(0,.11,0,.11)
  .apply(env => env.mul(env)
    .mul(158)
    .sine(env)
    .distort(.85)
  ))
  impulse(2).kick().out()`]});let _=0;function J(t,e,n){return O(t,(...i)=>{const o=_++;return i=i.map((u,a)=>b(u).asModuleInput(t,o,a)),e(...i).asModuleOutput(t,o)},n)}p.set("n",{tags:["math"],description:"Constant value node. Turns a number into a Node.",ins:[{name:"value",default:0}]});function k(t){return Array.isArray(t)?poly(...t.map(e=>k(e))):typeof t=="object"?t:g("n",t)}p.set("out",{tags:["meta"],description:"Sends the node to the audio output (dac)"}),s.prototype.out=function(){return dac(this)},p.set("withIns",{internal:!0,tags:["innards"],description:"Sets the inputs of a node. Returns the node itself",ins:[{name:"in",dynamic:!0}]}),s.prototype.withIns=function(...t){return this.ins=t,this},p.set("flatten",{internal:!0,tags:["innards"],description:"Flattens the node to a list of all nodes in the graph, where each Node's ins are now indices"}),s.prototype.flatten=function(){return C(this)},p.set("dagify",{internal:!0,tags:["innards"],description:"Removes all cycles and replaces them with feedback_read / feedback_write Node's"}),s.prototype.dagify=function(){return q(this)},p.set("apply",{graph:!0,tags:["meta"],description:"Applies the given function to the Node. Useful when a node has to be used multiple times.",examples:[`impulse(4)
  .apply(imp=>imp
    .seq(110,220,330,440)
    .sine()
    .mul( imp.ad(.1,.1) )
  ).out()`]}),s.prototype.apply=function(t){return t(this)},p.set("clone",{internal:!0,tags:["innards"],description:"Clones the node"}),s.prototype.clone=function(){return new s(this.type,this.value).withIns(...this.ins)},p.set("map",{tags:["meta"],description:"Applies the given function to all ins if it's poly node. Otherwise it applies the function to itself.",examples:[`n([110,220,330])
  .map( freq=>freq.mul([1,1.007]).saw().mix() )
  .mix(2).mul(.5).out()`]}),s.prototype.map=function(t){return this.type!=="poly"?t(this):poly(...this.ins.map(t))},p.set("select",{tags:["meta"],graph:!0,description:"Find the first occurence of the given type up in the graph and returns the match. Useful to exit a feedback loop at another point.",examples:[`sine(220).mul(impulse(1).ad(.001,.2))
  .add( x=>x.delay(.2).mul(.8) )
  .select('delay').out()
  `]}),s.prototype.select=function(t){for(let e of this.ins){if(e.type===t)return e;const n=e.select(t);if(n)return n}},p.set("debug",{tags:["meta"],description:"Logs the node to the console"}),s.prototype.debug=function(t=e=>e){return console.log(t(this)),this};function L(t){const e=modules.get(t),n=Array.from({length:e.length},(o,u)=>g(`$INPUT${u}`)),i=e(...n);return JSON.stringify(i,null,2)}function v(t,e){if(t===e)return!0;for(let n of t.ins)if(n.ins.includes(e)||v(n,e))return!0}s.prototype.loopsToMe=function(t){return v(t,this)};function q(t){if(t.type!=="exit")throw new Error("dagify should be called on an exit node");let e=[];function n(i){if(e.includes(i)){const o=i.ins.filter(u=>v(u,i));if(!o.length)return;o.forEach(u=>{const a=i.ins.indexOf(u),r=new s("feedback_read");i.ins[a]=r;const l=new s("feedback_write");l.ins=[u],l.to=r,t.ins.push(l)});return}if(e.push(i),!!i.ins.length)for(const o of i.ins)n(o)}return n(t),t}function x(t,e=[]){return e.push(t),t.ins.forEach(n=>{e.includes(n)||x(n,e)}),e}function C(t){const e=x(t);return e.map(n=>{let i={...n,type:n.type,ins:n.ins.map(o=>e.indexOf(o)+"")};return n.value!==void 0&&(i.value=n.value),n.to!==void 0&&(i.to=e.indexOf(n.to)),i})}function F(t){let e=[];return s.prototype.out=function(){e.push(this)},Function(t)(),dac(...e).exit()}s.prototype.over=function(t){return this.apply(e=>add(e,t(e)))},s.prototype.dfs=function(t,e){return this.apply(n=>N(n,t,e))},s.prototype.apply2=function(t){return t(this,this)};let N=(t,e,n=[])=>(t=e(t,n),n.push(t),t.ins=t.ins.map(i=>n.includes(i)?i:N(i,e,n)),t);s.prototype.asModuleInput=function(t,e,n){return this.inputOf=this.inputOf||[],this.inputOf.push([t,e,n]),this},s.prototype.asModuleOutput=function(t,e){return this.outputOf=[t,e],this};function M(t,e={}){const{log:n=!1,lang:i="js",fallbackType:o="thru",constType:u="n",varPrefix:a="n"}=e;n&&console.log("compile",t);const r=t.flatten(!0),l=A(r);let c=[],d=h=>r[h].type!==u?`${a}${h}`:typeof r[h].value=="string"?`"${r[h].value}"`:r[h].value;const y=[];for(let h of l){const T=r[h],E=r[h].ins.map(z=>d(z)),P=y.length;let m=p.get(T.type);m||(console.warn(`unhandled node type "${r[h].type}". falling back to "${o}"`),m=p.get(o));const U={vars:E,node:T,nodes:r,id:h,ugenIndex:P,ugen:m.ugen,name:d(h),lang:i};m.compile&&c.push(m.compile(U)),m.ugen&&y.push({type:m.ugen,inputs:E})}const I=c.join(`
  `);return n&&(console.log("compiled code:"),console.log(I)),{src:I,ugens:y}}s.prototype.compile=function(t){return M(this.dagify(),t)};function A(t){function e(r){let l=t[r],c=0;for(let d=0;d<l.ins.length;++d){let y=l.ins[d];y&&(o.has(y)||c++)}return c}let n=[],i=[],o=new Set,u=new Map;for(let r in t)e(r)==0&&n.push(r);for(let r in t)u.set(r,[]);for(let r in t){let l=t[r];for(let c=0;c<l.ins.length;++c){let d=l.ins[c];if(d===void 0)continue;let y=l.ins[c];u.get(y).push([r,d])}}for(;n.length>0;){var a=n.pop();i.push(a);let r=u.get(a);for(let[l,c]of r)o.add(c),e(l)==0&&n.push(l)}if(i=Array.from(new Set(i)),i.length!=Object.keys(t).length)throw SyntaxError("graph contains cycles");return i}return f.Node=s,f.compile=M,f.evaluate=F,f.exportModule=L,f.getInletName=j,f.module=J,f.n=k,f.node=g,f.nodeRegistry=p,f.register=O,f.registerNode=R,f.topoSort=A,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"}),f}({});
  